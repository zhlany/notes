# HashMap

Hashmap
它的底层是数组+链表+红黑树（jdk1.8）
当我们存储kv时，底层会获取key通过hash算法获取它的哈希值，在通过hash和数组的长度来确定数组的下标位，就是确定将kv存放在哪个位置，如果有相同的下标位的就会在该位置形成链表，在链表的尾部插入，当这个链表的长度超过8时就会将链表转化成红黑树，红黑树它是自平衡二叉树，转化的目的也是为了提高查找的效率。

其次，我也去了解了go的hash表，它的底层是数组+链表
其中包含了hmap和bmap,hmap是最外层的数据结构，主要作用计算hash值，定位bmap,以及数组长度，扩容，等等这些。bmap就是确切存储kv的数组，一个bmap可以存储8个kv，然后bmap的kv是排列顺序的，比如有多的kv时,它的存储就是kkvv,如果插入的kv超过8个，就会在该数组后形成链表来存储该kv.



# Spring

Spring

该框架主要是为了解决应用开发的业务逻辑和其他各层的耦合问题。简化Java·开发。

依赖注入和面向切面编程

核心：
IOC容器和AOP模块，通过IOC容器来管理bean,以及他们之间的耦合度；通过AOP以动态非入侵的方式增强服务。

优点：
方便解耦，简化开发，将所有对象的创建和依赖关系的维护交给Spring管理。
AOP编程的支持
方便对程序进行权限拦截，以及运行监控等功能。
事务的支持
只需要通过配置就可以完成对事务的管理，无需手动编程。
同时接受其他优秀的框架

缺点：
学起来比较费劲，我都已经看了好几遍了

注入方式：set注入，构造器注入，接口注入
常用注解：Component、resource、value、getMapping、service、controller

# SpringMVC

SpringMVC是基于Java实现MVC设计模式的请求驱动类型的轻量级web框架。

SpringMVC的工作流程：
用户请求至前端控制器，
由前端控制器调用处理器映射器返回具体的处理器
再由前端控制器调用处理器适配器来执行这个处理器（controller），这个处理器就是控制层，控制层会调用业务层的逻辑代码，最终返回相应的视图模型，然后前端控制器会将这个视图模型传给视图解析器进行解析，解析后返回具体的视图，前端控制器再对这个试图进行渲染（就是模型数据填充视图），渲染之后就响应给客户了。

# gin

go的一个微框架，封装比较优雅，API比较友好。
借助框架，可以省去很多常用的封装带来的时间。

# git

多人协作开发
数据备份
版本分支
权限管理
历史记录

多人开发，谁正在修改，谁正在提交，时时保持自己的代码是最新的

代码的备份，历史代码的备份

对历史版本形成一个按照
满足了测试基线 质管部门

git init --初始化

创建全局用户

创建项目用户
项目用户优先级高于全局用户

git config --global user.name "Username"
git config --global user.email "Username@example.com"

git status           查看状态
git add .               将项目中未被跟踪的文件都加入到仓库中，
git commit -m "Started project"       提交
git log          查看提交历史
git checkout .          撤销
 git log --pretty=oneline         检查以前的提交
rm -rf .git       删除仓库

git reflog
git reset -hard "daima"
git log --oneline

$ git branch v2  
git chechout v2  //main-->v2


文件上传：
git remote add origin https:``//自己的仓库 url 地址
git remote add origin https://github.com/IT-HUY/Repository_first.git  //创建新的github仓库

需要先获取远端更新并与本地合并，再git push。
git fetch origin   //获取远程更新
git merge origin/master
git push origin master  //上传到github
ssh上传：
 git push -u origin master 
git@github.com:IT-HUY/Repository_first.git




# git2

它是一个强大的分布式版本控制系统

git status 查看当前状态
git add 添加项目到仓库
git commit -m "" 提交
git log 查看历史提交
git checkout 撤销 
rm -rf .git 删除仓库

git remote add origin "" 文件上传至远端仓
git remote -v 查看远端仓库
git remote add [name] [url] 添加远端仓库
git remote rm 删除远端仓库


git branch 查看本地分支

# go基础

go
编译快、运行效率高、高并发，数组安全
主要用于web服务器
基础语法：
多个标记组成：关键字、常量、字符串、符号、标识符、
布尔类型、数字类型(整形、浮点型)、字符串类型、
派生类型：
指针、数组、结构化、通道、接口、切边、Map

# go并发模型

两种并发形式
多线程共享内存并发模型
CSP并发模型（go特有特殊的两极线程模型）

线程并发模型
线程间通信就是通过共享内存的方式来进行的，访问共享数据的时候，通过锁来访问

CSP并发模型主要是由协程+管道实现，强调“以通信的方式来实现内存共享”

go并发的实现原理

# go的协程机制

go⁮线程实现模型

go的CSP高并发模型的实现主要是go特有的线程实现模型GPM调度模型
GPM模型中
M代表一个系统线程
P代表逻辑处理器
G代表协程，是一个轻量级的线程，协程要依赖线程来进行


一个内核线程会连接一个逻辑处理器，一个逻辑处理器会连接一个或者多个协程，

每创建一个协程会放到go的调度器的全局运行列队等待被分配到一分逻辑处理器的本地列队中，等待被执行


如果线程遇到阻塞，此时线程会放弃逻辑处理器，让其他线程接收逻辑处理器，继续调度协程执行。

本地列队就是逻辑处理器存放协程等待被调度的地方，他需要从全局列队中获取新的协程，二我们创建协程时就会向去全局列队上等到处理器的本地列队获取，每个逻辑处理器都有属于他自己的本地列队。

总结：
A GO的并发模型有两种1多线程，2 MPG模型
B M关联了KSE内核线程，P为逻辑处理器，G为goroutine
C MPG关系： M关联了一个内核线程，通过调度器的调度，可以连接1个或者多个G,相当于把一个内核线程切分成了了N个用户线程。 M和P是一对一的关系，通过P调度N个G（P和G是一对多关系），实现内核线程和G的多对多关系（M:N），通过这个方式，一个内核线程可以起N个Goroutine,同样硬件配置的机器可用的用户线程成几何级增长，并发性大幅提高
D 发生阻塞之后，线程和goroutine会从逻辑处理器P上分离，该线程会继续阻塞，等待系统调用返回。而P被绑定到新的M上，从而会从本地队列选取另一个goroutine来运行。而等阻塞完成后，对应的goroutine会放回本地运行队列，线程会保存好，以便之后继续使用。
E 每个P都有本地队列（LRQ local runnable queue），叫runqueue，如果自己的G都执行结束了，代表LRQ为空。此时P会从别的P窃一些G来运行，一次取其一半的量。这被称为work-stealing。(额读书人的事能叫偷么，只能称之为窃)
还有个概念叫GRQ 全局可运行队列，GRQ 存储全局的可运行 goroutine，这些 goroutine 还没有分配到具体的 P。




# grpc

grpc是高性能、开源、通用的RPC框架。

客户端可以直接调用不同服务器上的远程程序
很容易的去构建分布式应用和服务

客户端根据接口描述直接调用需要的服务


# java

面向对象：就是站在对象的角度去思考问题，把多个功能合理放到不同的对象里，比较强调的是这个对象具备的某些功能

重载、重写
重载：就是同名不同参，有相同的方法名，但是它引用的参数可以是不相同的，这就是重载

重写：子类把父类的方法重新写一遍，然后子类可以对该方法体进行修改，使用自己的内容，这就是重写


# linux的基本命令

pwd  显示当前目录
ls -a -l 显示当前目录下的文件
vi 编辑文件文本
cd 切换目录
cat 显示文件所有内容
touch 创建一个文件
mkdir 创建一个目录
mv 移动文件
cp 拷贝
rm 删除
sudo root身份运行
su root 更换root用户
chmod 更改文件权限
chown 更改文件所有者





# map

map底层使用哈希表来实现，底层实现是 数组+链表
主要包含hmap和bmap两个底层结构
hmap是最外层的一个数据结构，只要记录保存的元素的个数，计算哈希值，存储bmap数组的地址，还有扩容因子等等这些，
bmap就是桶单元，数据的存储就是在单元里面，然后每一个单元能够存储8个键值，然后这些键值是以排列的方式存储，比如kkkvvv这样，如果超过桶的长度，扩容的桶单元会组成链表的结构存储，就是两个桶连接在一次嘛。
当我们存储键值时，hmap会通过key来计算它的哈希值，然后将这个哈希值一分为二，地位哈希值主要是为了找桶数组，高位哈希值主要是为了找桶单元，然后将就将键值存储到指定的桶单元；

它的创建使用make来创建，如果存储的元素个数超过了桶个数的6.5倍，他就会触发扩容机制，扩容有等量扩容和翻倍扩容，因为2的B次方就是桶的个数嘛，如果这个B<=15的话就会出发等量扩容，>15的话就会出发翻倍扩容。

# mybatis

mybatis是半ROM框架，然后它内部封装了JDBC、加载驱动、创建连接等频繁的过程。使用这个框架只选哟关注编写sql语句即可。

# mysql

innoDB

底层B+树
它支持事务，
然后支持外键约束，（只有它）
支持自动增加列属性
经常更新的表，适合处理多重并发的更新请求
但是他占用空间较大

myiasm（默认）
不支持外键，不支持事务，不支持行锁，并发性能差
插入更新需要全表锁，性能差
但是它读取操作的速度很快，不会占用大量的内存和存储资源。

索引：
是帮助myqsl高效获取数据的数据结构。

4种不同的索引：
主键索引、
唯一索引、保证每一行的诗句唯一性
普通索引、
全文索引
索引会降低增、改、删等速度
然后它会占用物理和数据空间

三范式：
第一范式：列不可分
第二范式：行可以唯一区分，主键约束
第三范式：表的非主属性不能依赖其他表的非主属性

事务：
原子性：事务是一个完整的操作，要么都去执行，要么都不执行
隔离性：事务与事务之间互不影响，彼此隔离
永久性：对数据库的修改会被永久保持
一致性：事务完成之后，数据必须是一致的状态


# new、make

Make主要使用在创建map,slice,channel等类型的实例。
New 则主要创建struct的实例，没有数据类型，返回该实例的指针。


# nginx

所有的配置文件都在/etc/nginx下，
并且每个虚拟主机已经安排在了/etc/nginx/sites-available下  
程序文件在/usr/sbin/nginx  
日志放在了/var/log/nginx中  
并已经在/etc/init.d/下创建了启动脚本nginx  
默认的虚拟主机的目录设置在了/var/www/nginx-default


Nginx的配置文件是/etc/nginx/nginx.conf，其中设置了一些必要的参数，我们发现其中这样的语句：
include /etc/nginx/sites-enabled/*

可以看出/etc/nginx/sites-enabled/default文件也是一个核心的配置文件，其中包含了主要的配置信息，如服务器跟目录、服务器名称、location信息和server信息


# redis

redis：非关系型数据库，缓存数据库，高性能的key-value数据库。

数据类型，string，list,set，sortset,hash

速度快，数据库存在内存中
它支持事务，操作的都是原子性
单进程单线程

为什么快
纯内存操作
单线程操作
采用非阻塞I/O多复用机制

持久化
RBD(默认)
按照一定的时间周期把内存中的数据以快照的形式保存到磁盘中。生成的快照文件是以rdb为后缀的文件。通过save参数来定义快照的时间周期。
AOF
这个就是记录你每次调用数据库的命令，当重启或者执行该文件时就会根据记录的命令重新创建数据库的内容。
数据库的回复优先选择AOF恢复

比较：
数据安全-RDB<AOF
相对于数据集比较大时，启动效率-RDB>AOF
性能-RDB>AOF



# redis集群

redis集群，
1.版本3.0.0以上，
    2.客户端连接集群没有统一的入口
    3.集群至少3个节点(投票容错机制要超过半数节点)

步奏:
    1.创建集群文件夹，用于存放集群节点
    2.复制redis的bin目录下的所有文件到集群的文件节点上
    3.修改节点的配置文件的端口号，自己开启集群搭建模式
    4.在复制各个节点给另外几个节点，修改他们端口号
    5.启动所有节点


# rpc

RPC是一个计算机通信协议
可以实现远程的方法调用
就是通过一台计算机程序调用另一台计算机的子程序

为什么要用：主要是可以实现远程程序的调用，

4个条件：
公共：结构体、函数名首字母大写
指针：函数第一个是接收参数，第二个是返回给客户端的参数，而且必须是指针类型
返回err：函数最后一个需要返回一个error

流程：
服务器端：
   1.注册服务
   2.将服务绑定到http协议上
   3.在监听服务，等待客户端连接调用

   （2.简历连接，等待连接）

客户端：
    1.连接远程rpc服务
    2.调用方法

# slice

array
普通的数据它的大小是固定的，是值传递

slice是一种数据结构
可以理解为它是一个指向数组的指针，也可以理解理解它为动态数据，可以动态扩容数组。slice的结构主要由指针，长度，容量组成，指针指向数组的地址，同时也可以指向它底层数组的某些元素的集合，长度就是已经初始化数组的长度，容量就是底层数组的大小了，然后它的长度会一直小于或者等于它的容量，当追加元素超过了它的容量，就会出发扩容机制，每次扩容会创建新的数组，将原来的数组复制到新的数组里面，容量扩容为原来的2倍，如果它的容量超过了1024，那他的扩容会是原来的0.25倍。而原来的数组会因为没在使用被GC扫描回收


# tcp_ip

它是一套支持网络通信的协议集

应用层
表示层
会话层
传输层
网络层
数据链路层
物理层

应用层
传输层
网络互联层
主机到网络层


# 参考

基本编码

掌握水平

常用特性

编程的基础知识、概念
链表、数组、简单树、   基本算法（排序、查找）

计算机基础知识：
进程、线程、协程
linux基本命令 
网络基础

# 特性

静态强类型、编译型、并发性，具有垃圾回收功能的编程语言

特性：
1语法简单

2并发模型
高并发是go的主要特点
协程就是是go特有的.比线程更小的轻量线程，启动协程不需要去关注线程的切换，只用一个go关键字就能启动一个协程
结合管道一起使用实现CSP模型，实现“在通信上实现内存共享”

3内存分配

4垃圾回收

5静态链接
编译后就是一个可执行文件，不需要附加任何东西就能部署

6标准库
不用借助第三方就可以完成大部分基础的功能开发

7工具链比较完整
比如编译，格式化，错误，检查，以及完整的测试框架

# 进程、线程、协程

进程相当于一个应用程序、是关于某个数据集合上的一次运行活动，是一个独立的单位，有自己独立的内存空间。
线程就是进程中实际运行的实体，一个进程会有多个线程，由cpu进行调度，可以并发
协程是go特有的轻量级线程，它的调度由用户控制。


# 连接池

c3p0与druid的区别

c3p0是一个开源的JDBC连接池

druid不仅仅是一个数据库连接池，
其中还包含一系列的JDBC内置组件，还有sql解析器，
1.支持所有JDBC兼容的数据库。
2.可以监控数据库的访问性能。
3.获得sql执行日志，监控数据库访问情况



每次我们频繁的使用数据库时都会不断的连接断开，连接断开，很消耗内存资源。
    使用数据库连接池连接数据库，在初始化连接池时就会提前创建一定的数据库连接于池中，程序要连接数据库就会直接向连接池申请连接，使用完连接池会回收连接，等待下次的调用。

