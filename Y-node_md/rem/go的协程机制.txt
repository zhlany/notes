go⁮线程实现模型

go的CSP高并发模型的实现主要是go特有的线程实现模型GPM调度模型
GPM模型中
M代表一个系统线程
P代表逻辑处理器
G代表协程，是一个轻量级的线程，协程要依赖线程来进行


一个内核线程会连接一个逻辑处理器，一个逻辑处理器会连接一个或者多个协程，

每创建一个协程会放到go的调度器的全局运行列队等待被分配到一分逻辑处理器的本地列队中，等待被执行


如果线程遇到阻塞，此时线程会放弃逻辑处理器，让其他线程接收逻辑处理器，继续调度协程执行。

本地列队就是逻辑处理器存放协程等待被调度的地方，他需要从全局列队中获取新的协程，二我们创建协程时就会向去全局列队上等到处理器的本地列队获取，每个逻辑处理器都有属于他自己的本地列队。

总结：
A GO的并发模型有两种1多线程，2 MPG模型
B M关联了KSE内核线程，P为逻辑处理器，G为goroutine
C MPG关系： M关联了一个内核线程，通过调度器的调度，可以连接1个或者多个G,相当于把一个内核线程切分成了了N个用户线程。 M和P是一对一的关系，通过P调度N个G（P和G是一对多关系），实现内核线程和G的多对多关系（M:N），通过这个方式，一个内核线程可以起N个Goroutine,同样硬件配置的机器可用的用户线程成几何级增长，并发性大幅提高
D 发生阻塞之后，线程和goroutine会从逻辑处理器P上分离，该线程会继续阻塞，等待系统调用返回。而P被绑定到新的M上，从而会从本地队列选取另一个goroutine来运行。而等阻塞完成后，对应的goroutine会放回本地运行队列，线程会保存好，以便之后继续使用。
E 每个P都有本地队列（LRQ local runnable queue），叫runqueue，如果自己的G都执行结束了，代表LRQ为空。此时P会从别的P窃一些G来运行，一次取其一半的量。这被称为work-stealing。(额读书人的事能叫偷么，只能称之为窃)
还有个概念叫GRQ 全局可运行队列，GRQ 存储全局的可运行 goroutine，这些 goroutine 还没有分配到具体的 P。


