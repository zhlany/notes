# 协程调度&GMP&并发编程（核心）

## ##

进程：计算机程序执行时分配的资源，包括**内存，磁盘空间，打开的文件**等，是操作系统进行资源分配和调度的一  个基本单位，通常包括一个或者多个线程。

线程：是操作系统进行任务调度的基本单位，由操作系统进行调度；线程会共享进程的内存和资源。

协程：协程是用户态的轻量级线程。调度由用户控制。协程之间得切换在用户态完成，切换开销较小。适用于高并发，对任务切换的场景。



## GO

**go中主线程就时一个物理线程**，可以发起对个协程

**go特点：有独立的栈空间，共享程序堆空间；调度由用户控制**



go协程都由runtime管理（新建、恢复、停止、休眠，其中执行异步操作时goroutine会陷入休眠，*不占用系统线程*（这是go协程很方便的一点），当新建或者恢复时加到任务队列中）

goroutine状态：idle,runnable,running,syscall,waiting,dead,copystack

 空闲中(idle): 新建,但未初始化

 待运行(runnable): 在运行队列中, 等待M取出并运行 

运行中(running): 表示machine正在执行这个routine 

系统调用中(syscall): 正在运行的routine发起的系统调用

 等待中(waiting): 在等待某些条件完成,不在执行也不在运行队列中(可能在channel的等待队列中)

 已中止(dead): 未被使用或可能已执行完毕

 栈复制中(copystack): 正在获取一个新的栈空间并把原来的内容复制过去(用于防止GC扫描)



## GMP

G:协程，有自己的栈空间（初始化2k，随需求增长），定时器

M:内核线程，真正运行程序的地方，记录内核线程栈的信息，go被调度到M上时，使用go自己的栈信息

P:调度器，负责调度go，维护本地go列队（G<=256），主线程从调度器上获取go并执行，



关系：P绑定在M上，P的数量<=M，G是通过P调度获取

某一时刻，一个M上只有一个G（g0除外），在P上拥有一个G列队，里面是已经准备就绪的G，可以被调度到M上执行，称为执行列队



全局列队：存放等待运行的G

P的本地列队：优先创建的G会先存入P的本地列队，若本地列队已满，存入全局列队

P列队：程序启动时创建，MAX=*GOMAXPROCS*

M列队：OS分配到的内核线程数



### 调度策略

#### 1复用线程

- work stealing机制：M无可运行的G时，尝试从其他M绑定的P中偷取G（一般是一半）而不是销毁线程
- hand off机制：M由于G发生阻塞时(锁、文件 I/O、网络 I/O 等)，M释放绑定的P，将P转给其他空闲的M线程来执行

#### 2并行

`GOMAXPROCS`设置P的数量，最多有`GOMAXPROCS`个线程分布在多个CPU上同时运行

#### 3抢占：

G最多只能占用CPU 10ms，防止其他协程处于饥饿状态

#### 4全局G列队

当M从work stealing机制获取不到G，可以从全局G列队中获取



### go指令调度流程

- go func() 创建一个协程
- 放入P的本地列队
- M从P中获取G执行
  1. M阻塞，runtime会将M解绑P，然后创建一个新的M来执行这个阻塞的G
  2. M系统调用结束，G尝试获取空闲的P来执行；若取不到P，M则进行休眠，G则放入全局列队



![指令调度流程](https://github.com/zhlany/notes/blob/master/go/Picture/%E6%8C%87%E4%BB%A4%E8%B0%83%E5%BA%A6%E6%B5%81%E7%A8%8B.jpg)

![调度器生命周期](https://github.com/zhlany/notes/blob/master/go/Picture/%E8%B0%83%E5%BA%A6%E5%99%A8%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F.png)



## M0和G0

M0 是启动程序后的编号为 0 的主线程，这个 M 对应的实例会在全局变量 runtime.m0 中，不需要在 heap 上分配，**M0 负责执行初始化操作和启动第一个 G**， 在之后 M0 就和其他的 M 一样了。

G0 是每次启动一个 M 都会第一个创建的 gourtine，G0 仅用于负责调度的 G，G0 不指向任何可执行的函数，每个 M 都会有一个自己的 G0。在调度或系统调用时会使用 G0 的栈空间，全局变量的 G0 是 M0 的 G0。
